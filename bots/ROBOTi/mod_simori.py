import database
import requests
import os, time, sys

# models.py (exemplo)

class RepositorioModel:
    def find_by_id(self, repo_id):
        return database.query("SELECT * FROM simori.repository WHERE id_rp = %s", (repo_id,))


class OaiRecordModel:
    def find_all(self, repository, status, deleted, harvesting, xml_not_null=False):
        sql = """SELECT * FROM simori.oai_records
                 WHERE repository = %s AND status = %s AND deleted = %s
                 AND harvesting = %s"""
        if xml_not_null:
            sql += " AND xml IS NOT NULL"

        return database.query(sql, (repository, status, deleted, harvesting))

    def update(self, record_id, data):

        database.update2("simori.oai_records", data, where="id = %s", params=(record_id,))


class OaiSetModel:
    def find_by_spec(self, repo_id, set_spec):
        sql = "SELECT * FROM simori.oai_sets WHERE identify_id = %s AND set_spec = %s"
        return database.query(sql, (repo_id, set_spec))


class OaiTriplesModel:
    def extract_triples(self, record, set_spec_id, repo_id):
        # implementa√ß√£o da extra√ß√£o de triples (a partir do XML, por ex.)
        print(f"Extraindo triples de {record[1]}...")


def simori_triples(repo_id):
    """
    Realiza a extra√ß√£o de metadados (triples) para um reposit√≥rio espec√≠fico.
    """
    repo_model = RepositorioModel()
    record_model = OaiRecordModel()
    triples_model = OaiTriplesModel()
    set_model = OaiSetModel()

    # üîπ Recupera informa√ß√µes do reposit√≥rio
    repo = repo_model.find_by_id(repo_id)
    if not repo:
        return "Reposit√≥rio n√£o encontrado."

    # üîπ Seleciona registros v√°lidos para processamento
    records = record_model.find_all(
        repository=repo_id,
        status=1,
        deleted=0,
        harvesting=1,
        xml_not_null=True
    )

    total = len(records)
    output = []

    # üîπ Loop principal: processa cada registro
    for i, record in enumerate(records, start=1):
        msg = f"Processando registro ID {i}/{total}<br>"
        print(f"[{i}/{total}] Iniciando extra√ß√£o...")

        identifier = (record[2]).strip()
        set_spec_name = record[4].strip()
        print(f"Identificador: {identifier}, setSpec: {set_spec_name}")

        if not identifier:
            continue

        set_spec_row = set_model.find_by_spec(repo_id, set_spec_name)
        print(f"setSpec Row: {set_spec_row}")  # Debug: exibe a linha do setSpec
        set_spec_id = set_spec_row[0][0] if set_spec_row else None

        msg += f"üîπ Processando: <code>{identifier}</code><br>"
        msg += f"setSpec: <code>{set_spec_name}</code> (ID: {set_spec_id})<br>"

        # üîπ Extrai triples
        triples_model.extract_triples(record, set_spec_id, repo_id)

        # üîπ Atualiza status do registro
        record_model.update(record[0], {"harvesting": 2})

        msg += f"‚úÖ Extra√ß√£o conclu√≠da para <b>{identifier}</b><br><br>"
        output.append(msg)

    # üîπ Finaliza√ß√£o
    final_msg = "üèÅ Extra√ß√£o finalizada para o reposit√≥rio."
    # Retorna HTML consolidado (para exibi√ß√£o via Flask ou Jinja)
    return final_msg

def get_register(base_url: str, identifier: str, record: dict):
    base_url = base_url + "?verb=GetRecord&metadataPrefix=oai_dc&identifier=" + identifier
    response = requests.get(base_url, {}, timeout=15)
    response.raise_for_status()
    xml = response.text
    return xml

def simori_harvesting(repo_id: int):
    repo_model = RepositorioModel()
    record_model = OaiRecordModel()
    triples_model = OaiTriplesModel()
    set_model = OaiSetModel()

    """
    Coleta os registros de um reposit√≥rio OAI e salva o XML de cada registro.
    """

    # üîπ Recupera informa√ß√µes do reposit√≥rio
    repo = repo_model.find_by_id(repo_id)
    if not repo:
        return "Reposit√≥rio n√£o encontrado."

    if not repo:
        print("‚ùå Reposit√≥rio n√£o encontrado.")
        return "Reposit√≥rio n√£o encontrado."

    # üîπ Busca registros ainda n√£o coletados
    # üîπ Seleciona registros v√°lidos para processamento
    records = record_model.find_all(
        repository=repo_id,
        status=0,
        deleted=0,
        harvesting=0,
        xml_not_null=True
    )

    total = len(records)

    if not records:
        print("‚ÑπÔ∏è Nenhum registro pendente de coleta.")
        return "Nenhum registro pendente de coleta."
    repo = repo[0]
    oai_url = repo[4].rstrip("/")
    print(f"üåê Iniciando coleta no reposit√≥rio: {repo[1]} ({oai_url})")
    print(f"üî∏ Total de registros a coletar: {len(records)}\n")

    # üîπ 3. Para cada registro, baixa o XML via GetRecord
    for idx, record in enumerate(records, start=1):
        identifier = (record[2] or "").strip()
        if not identifier:
            continue

        print(f"üîπ [{idx}/{len(records)}] Coletando: {identifier}")
        try:
            xml = get_register(oai_url, identifier, record)
            database.update2(
                "simori.oai_records",
                {"xml": xml, "harvesting": 1, "status": 1},
                where="id = %s",
                params=(record[0],)
            )
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao coletar {identifier}: {e}\n")

        # Delay opcional para n√£o sobrecarregar o servidor remoto
        # time.sleep(0.5)  # 0.5 segundos

    print("üèÅ Coleta finalizada para o reposit√≥rio.")
    print(f"üîô Retorne √† p√°gina: /repository/show/{repo_id}")
    return "Coleta conclu√≠da."

if __name__ == "__main__":
    # Exemplo de execu√ß√£o direta
    repo_id = 89 # ID do reposit√≥rio a ser processado
    result_html = simori_harvesting(repo_id)
    result_html = result_html + simori_triples(repo_id)
    print(result_html)  # Ou renderizar via Flask/Jinja conforme necess√°rio